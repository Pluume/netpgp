{
  "_args": [
    [
      "node-pgp",
      "/home/bluff/Code/Javascript/netpgp"
    ]
  ],
  "_from": "node-pgp@latest",
  "_id": "node-pgp@0.0.1",
  "_inCache": true,
  "_installable": true,
  "_location": "/node-pgp",
  "_npmUser": {
    "email": "cdauth+npmjs.org@cdauth.eu",
    "name": "cdauth"
  },
  "_npmVersion": "1.1.64",
  "_phantomChildren": {},
  "_requested": {
    "name": "node-pgp",
    "raw": "node-pgp",
    "rawSpec": "",
    "scope": null,
    "spec": "latest",
    "type": "tag"
  },
  "_requiredBy": [
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/node-pgp/-/node-pgp-0.0.1.tgz",
  "_shasum": "c5f1a8e3a7306248495d569f2c109a00eb495385",
  "_shrinkwrap": null,
  "_spec": "node-pgp",
  "_where": "/home/bluff/Code/Javascript/netpgp",
  "bugs": {
    "url": "https://github.com/cdauth/node-pgp/issues"
  },
  "dependencies": {
    "async": "0.2.x"
  },
  "description": "A node.js implementation of OpenPGP.",
  "devDependencies": {},
  "directories": {},
  "dist": {
    "shasum": "c5f1a8e3a7306248495d569f2c109a00eb495385",
    "tarball": "https://registry.npmjs.org/node-pgp/-/node-pgp-0.0.1.tgz"
  },
  "homepage": "https://github.com/cdauth/node-pgp#readme",
  "license": "MIT",
  "maintainers": [
    {
      "name": "cdauth",
      "email": "cdauth+npmjs.org@cdauth.eu"
    }
  ],
  "name": "node-pgp",
  "optionalDependencies": {},
  "readme": "This project is work in progress. One day it is supposed to be a native\nJavaScript OpenPGP implementation following \n[RFC 4880](http://tools.ietf.org/html/rfc4880).\n\nThis page describes what is supported already.\n\nAPI documentation\n=================\n\n* [Keyring](#keyring)\n  * [Open a keyring file](#open-a-keyring-file)\n  * [Access keys and their sub-objects](#access-keys-and-their-sub-objects)\n  * [Add and remove objects](#add-and-remove-objects)\n  * [Save changes](#save-changes)\n  * [Web of trust](#web-of-trust)\n* [BufferedStream](#bufferedstream)\n* [Fifo](#fifo)\n* [Filter](#filter)\n* [Object info](#object-info)\n  * [Public key info](#public-key-info)\n  * [Public subkey info](#public-subkey-info)\n  * [User ID info](#user-id-info)\n  * [Attribute info](#attribute-info)\n  * [Signature info](#signature-info)\n* [Constants](#constants)\n* [Format conversion functions](#format-conversion-functions)\n\n\nTypes\n=====\n\nKeyring\n-------\n\nThe Keyring class represents a collection of keys and can be used to access\ninformation about them. node-pgp ships a simple implementation of a keyring\nclass reading keys from a file, storing them in memory and saving changes\nback to the file. There are other implementations, such as\n[node-pgp-postgres](https://github.com/cdauth/node-pgp-postgres).\n\n### Open a keyring file ###\n\nIn order to create a keyring object from a file, use the following code:\n\n```javascript\nvar filename = \"/tmp/keyring.pgp\";\nvar create = true; // Create the file if it does not exist?\npgp.keyringFile.getFileKeyring(filename, function(err, keyring) {\n\t// keyring is the Keyring object\n}, create);\n```\n\nWhen you are finished using a Keyring object, you should call `keyring.done()`,\nso that all file handles (or database connections) are closed.\n\n### Access keys and their sub-objects ###\n\nThe hierarchy of objects is as follows:\n\n* Public key\n\t* Signature\n\t* Public subkey\n\t\t* Signature\n\t* Identity\n\t\t* Signature\n\t* Attribute\n\t\t* Signature\n\nEach object is referenced by an ID that is unique within the context of its parent\nobject. Keys and subkeys are referenced by their long ID, a 16-digit uppercase hexadecimal\nnumber. Identities are referenced by the string of their identity. Attributes and signatures\nare referenced by a 27-character alphanumeric checksum of their content.\n\n#### get*List() ####\n\n* `Keyring.getKeyList([filter])`\n* `Keyring.getKeySignatureList(keyId[, filter])`\n* `Keyring.getSubkeyList(keyId[, filter])`\n* `Keyring.getSubkeySignatureList(keyId, subkeyId[, filter])`\n* `Keyring.getIdentityList(keyId[, filter])`\n* `Keyring.getIdentitySignatureList(keyId, identityId[, filter])`\n* `Keyring.getAttributeList(keyId[, filter])`\n* `Keyring.getAttributeSignatureList(keyId, attributeId[, filter])`\n* `Keyring.getParentKeyList(subkeyId)`\n\nReturns a [Fifo](#fifo) object with the IDs of the existing objects, optionally filtered\nby a [Filter](#filter).\n\n#### get*s() ####\n\n* `Keyring.getKeys([filter, [fields]])`\n* `Keyring.getKeySignatures(keyId, [filter, [fields]])`\n* `Keyring.getSubkeys(keyId, [filter, [fields]])`\n* `Keyring.getSubkeySignatures(keyId, subkeyId, [filter, [fields]])`\n* `Keyring.getIdentities(keyId, [filter, [fields]])`\n* `Keyring.getIdentitySignatures(keyId, identityId, [filter, [fields]])`\n* `Keyring.getAttributes(keyId, [filter, [fields]])`\n* `Keyring.getAttributeSignatures(keyId, attributeId, [filter, [fields]])`\n* `Keyring.getParentKeys(subkeyId)`\n* `Keyring.getAllSignatures(keyId, filter, fields)`\n\nReturns a [Fifo](#fifo) object with the existing object [infos](#object-info), optionally\nonly those that match the given [Filter](#filter). If a `fields` array is specified, the\nobject info objects will only contain those properties. This might improve performance\nwith some keyring implementations.\n\n`getAllSignatures()` returns all signatures of the key itself and of all its sub-objects.\n\n#### getSelfSigned*s() ####\n\n* `Keyring.getSelfSignedSubkeys(keyId[, filter[, fields]])`\n* `Keyring.getSelfSignedIdentities(keyId[, filter[, fields]])`\n* `Keyring.getSelfSignedAttributes(keyId[, filter[, fields]])`\n\nSame as above, but additionally returns these additional properties from the most recent\nself-signature: `expires`, `revoked`, `security`. Objects that do not contain a self-signature\nare not returned.\n\n#### *exists() ####\n\n* `Keyring.keyExists(keyId, callback)`\n* `Keyring.keySignatureExists(keyId, signatureId, callback)`\n* `Keyring.subkeyExists(keyId, subkeyId, callback)`\n* `Keyring.subkeySignatureExists(keyId, subkeyId, signatureId, callback)`\n* `Keyring.identityExists(keyId, identityId, callback)`\n* `Keyring.identitySignatureExists(keyId, identityId, signatureId, callback)`\n* `Keyring.attributeExists(keyId, attributeId, callback)`\n* `Keyring.attributeSignatureExists(keyId, attributeId, signatureId, callback)`\n\nCalls the `callback(err, exists)` function with a boolean to indicate whether an object with\nthe given ID exists.\n\n#### get*() ####\n\n* `Keyring.getKey(keyId, callback[, fields])`\n* `Keyring.getKeySignature(keyId, signatureId, callback[, fields])`\n* `Keyring.getSubkey(keyId, subkeyId, callback[, fields])`\n* `Keyring.getSubkeySignature(keyId, subkeyId, signatureId, callback[, fields])`\n* `Keyring.getIdentity(keyId, identityId, callback[, fields])`\n* `Keyring.getIdentitySignature(keyId, identityId, signatureId, callback[, fields])`\n* `Keyring.getAttribute(keyId, attributeId, callback[, fields])`\n* `Keyring.getAttributeSignature(keyId, attributeId, signatureId, callback[, fields])`\n* `Keyring.getSignatureById(signatureId, callback[, fields])`\n* `Keyring.getPrimaryIdentity(keyId, callback[, fields])`\n\nCalls the `callback(err, objectInfo)` function with an [info object](#object-info) for\nthe object with the specified ID. If the object does not exist, `null` is passed instead.\nBy specifying the `fields` array, you can limit the properties that the info object will\ncontain, which might increase performance with some keyring implementations.\n\nNote that `getSignatureById()` only returns verified signatures.\n\n`getPrimaryIdentity()` finds the primary identity of the key or null if the key does not\ncontain any identities at all.\n\n#### getSelfSigned*() ####\n\n* `Keyring.getSelfSignedSubkey(keyId, subkeyId, callback[, fields])`\n* `Keyring.getSelfSignedIdentity(keyId, identityId, callback[, fields])`\n* `Keyring.getSelfSignedAttribute(keyId, attributeId, callback[, fields])`\n\nSame as above, but additionally returns these additional properties from the most recent\nself-signature: `expires`, `revoked`, `security`. Objects that do not contain a self-signature\nare not returned.\n\n#### get*SignatureListByIsser() ####\n\n* `Keyring.getKeySignatureListByIssuer(issuerKeyId[, filter])`\n* `Keyring.getSubkeySignatureListByIssuer(issuerKeyId[, filter])`\n* `Keyring.getIdentitySignatureListByIssuer(issuerKeyId[, filter])`\n* `Keyring.getAttributeSignatureListByIssuer(issuerKeyId[, filter])`\n\nFinds signatures allegedly issued by the given key, optionally only those that match the given\n[filter](#filter). To only get those signatures that have really been issued by the given key,\nuse `{ verified: true }` as filter. Returns a [Fifo](#fifo) object.\n\nThe objects returned contain the following properties, depending on the context: `keyId`,\n`signatureId`, `subkeyId`, `identityId`, `attributeId`.\n\n#### search() ####\n\n* `Keyring.search(searchString)`\n* `Keyring.searchIdentities(searchString)`\n* `Keyring.searchByShortKeyId(shortKeyId)`\n* `Keyring.searchByLongKeyId(longKeyId)`\n* `Keyring.searchByFingerprint(fingerprint)`\n\nSearches the keyring for the given strings. `search()` unites all other search methods.\n\nA [Fifo](#fifo) object is returned that contains [key info](#public-key-info) objects, optionally\nwith an additional `subkey` or `identity` object containing the [info object](#object-info) of the\nmatched subkey or identity.\n\n#### exportKey() ####\n\n* `Keyring.exportKey(keyId[, selection])`\n\nExports the given key in binary format, returned as a [BufferedStream](#bufferedStream).\nWith the `selection` object, you can skip sub-objects during the export. Its format is\n`{ identities: { }, attributes: { }, subkeys: { }, signatures: { } }`, where the properties\nare objects mapping object IDs to booleans that indicate whether the objects should be exported.\nIf `selection.attributes` is undefined, all attributes are exported, if it is an empty object,\nno attributes are exported.\n\n### Add and remove objects ###\n\nChanges made to the keyring are not written to the underlying data storage (such as a file\nor a database) unless the save function is called.\n\n#### add*() ####\n\n* `Keyring.addKey(keyInfo, callback)`\n* `Keyring.addKeySignature(keyId, signatureInfo, callback)`\n* `Keyring.addSubkey(keyId, subkeyInfo, callback)`\n* `Keyring.addSubkeySignature(keyId, subkeyId, signatureInfo, callback)`\n* `Keyring.addIdentity(keyId, identityInfo, callback)`\n* `Keyring.addIdentitySignature(keyId, identityId, signatureInfo, callback)`\n* `Keyring.addAttribute(keyId, attributeInfo, callback)`\n* `Keyring.addAttributeSignature(keyId, attributeId, signatureInfo, callback)`\n\nAdds the object with the given [info](#object-info) to the keyring and then calls\nthe `callback(err)` function.\n\n#### remove*() ####\n\n* `Keyring.removeKey(keyId, callback)`\n* `Keyring.removeKeySignature(keyId, signatureId, callback)`\n* `Keyring.removeSubkey(keyId, subkeyId, callback)`\n* `Keyring.removeSubkeySignature(keyId, subkeyId, signatureId, callback)`\n* `Keyring.removeIdentity(keyId, identityId, callback)`\n* `Keyring.removeIdentitySignature(keyId, identityId, signatureId, callback)`\n* `Keyring.removeAttribute(keyId, attributeId, callback)`\n* `Keyring.removeAttributeSignature(keyId, attributeId, signatureId, callback)`\n\nRemoves the object with the given ID from the keyring and then calls the `callback(err)`\nfunction. If the item does not exist, an error *might* be raised.\n\n#### importKeys() ####\n\n* `Keyring.importKeys(keyData, callback[, acceptLocal])`\n\nImports the given keys to the keyring. `keyData` is a [BufferedStream](#bufferedstream) with\nkeys in binary format. After the import, `callback(err, imported)` is called, where `imported`\nis an object of the format `{ keys: [ ], failed: [ ] }`, `keys` containing an array of objects\nwith some information about the imported keys and `failed` containing an array of objects with\nsome information about the objects that failed to import.\n\nIf `acceptLocal` is set to `true`, local signature are not skipped.\n\n### Save changes ###\n\n* `Keyring.saveChanges(callback)`\n* `Keyring.revertChanges(callback)`\n\nSaves or reverts the changes made to the keyring and then calls `callback(err)`.\n\n### Web of trust ###\n\n* `Keyring.trust(keyId, callback)`\n* `Keyring.untrustKey(keyId, callback)`\n\nTrusts/untrusts the given key ID and then calls `callback(err)`. If a key is trusted,\nall the signatures made by it will be trusted and so the identities and attributes that\nit has signed. Also, trust signatures made by it will be trusted, so a chain of trust can\nbe built.\n\n\nBufferedStream\n--------------\n\nThis class makes reading from a Readable Stream predictable by providing methods\nthat ensure that a specified number of bytes is returned at once.\n\nObjects of this class are returned by several functions of this library. The\nfollowing methods can be used to read content from the stream. Note that all\nof them only read a , you can\nuse the following methods to read its content:\n\n### read(bytes, callback, strict) ###\n\nReads the specified number of bytes from the stream. If `strict` is set to true\n(which is the default value), an error is produced when the stream ends before\nthe number of bytes is available. If it is set to false, in that case, it will\nreturned a reduced number of bytes containing the rest of the stream.\n\n```javascript\nvar stream; // Of type BufferedStream\nstream.read(5, function(err, data) {\n\tif(err)\n\t\tconsole.warn(\"There has been an error. Maybe the stream has ended and less than 5 bytes are available.\");\n\telse\n\t\t; // data.length == 5\n});\nstream.read(5, function(err, data) {\n\tif(err)\n\t\tconsole.warn(\"There has been an error.\");\n\telse if(data.length < 5)\n\t\t; // The stream has ended. data contains the very last bytes of it.\n\telse\n\t\t; // data.length == 5\n}, false);\n```\n\n### readUntilEnd(callback) ###\n\nWaits until the stream has ended and then calls the callback function with the\nwhole amount of data.\n\n```javascript\nvar stream; // Of type BufferedStream\nstream.readUntilEnd(function(err, data) {\n\tif(err)\n\t\tconsole.warn(\"An error occurred\", err);\n\telse\n\t\t; // data contains the whole data\n});\n```\n\n### readLine(callback) ###\n\nReads a line from the stream. The line-break is included in the provided data.\n\n```javascript\nvar stream; // Of type BufferedStream\nstream.readLine(function(err, data) {\n\tif(err)\n\t\tconsole.warn(\"An error occurred\", err);\n\telse if(data.toString(\"utf8\").indexOf(\"\\n\") == -1)\n\t\t; // This is the last line of the stream\n\telse\n\t\t; // data contains a line ended with a line-break\n});\n```\n\n### readArbitrary(callback) ###\n\nReads an arbitrary amount of data from the stream, at least 1 byte. All data\nthat is currently available in the stream buffer will be passed to the callback\nfunction. This example passes all data from the stream to a writable stream.\n\n```javascript\nvar stream; // Of type BufferedStream\nvar writableStream;\nreadOn();\nfunction readOn() {\n\tstream.readArbitrary(err, data) {\n\t\tif(err)\n\t\t\tconsole.warn(\"There has been an error\", err);\n\t\telse if(data.length == 0)\n\t\t\twritableStream.end(); // The stream has ended\n\t\telse {\n\t\t\twritableStream.write(data);\n\t\t\treadOn();\n\t\t}\n\t};\n}\n```\n\n### whilst(iterator, callback) ###\n\nThis function works like the `whilst()` method from the `async` library. It calls\nthe `iterator` function with an arbitrary amount of data multiple times until the\nend of the stream is reached. Then, the `callback` function is called once with\na possible error message.\n\n```javascript\nvar stream; // Of type BufferedStream\nstream.whilst(function(data, callback) {\n\t// Do something with the data chunk, maybe something asynchronous\n\tvar error; // A possible error that happened during the processing of the data\n\tif(error)\n\t\tcallback(error); // Stops the reading and calls the second callback function with the error\n\telse\n\t\tcallback(); // Reads the next chunk or calls the second callback function if the stream has ended\n}, function(err) {\n\t// The stream has ended or an error occurred\n});\n```\n\n\nFifo\n----\n\nObjects of this type represent a queue of items.\n\nThere are two ways to read the items. The probably simpler one works similar to\nthe `forEachSeries()` method from the `async` library:\n\n```javascript\nvar fifo; // Of type Fifo\nfifo.forEachSeries(function(item, callback) {\n\t// Do something with item, maybe something asynchronous\n\tvar error; // A possible error that happened during the processing of the item\n\tif(error)\n\t\tcallback(error); // Breaks the loop and calls the second callback function with the error\n\telse\n\t\tcallback(); // Loops to the next item, or calls the second callback function without an error if no items are left\n}, function(err) {\n\t// The loop has ended\n});\n```\n\nThe other method reads each item manually by using the `next` function:\n\n```javascript\nvar fifo; // Of type Fifo\nreadNext();\nfunction readNext() {\n\tfifo.next(function(err, item) {\n\t\tif(err === true)\n\t\t\t; // No items left\n\t\telse if(err)\n\t\t\tconsole.log(\"An error occurred\", err);\n\t\telse\n\t\t{\n\t\t\t// Do something with item.\n\n\t\t\treadNext();\n\t\t}\n\t});\n}\n```\n\n\nFilter\n------\n\nFilters are used to filter objects by their properties. To get all version 4 keys with either\n2048 or 4096 bits for example, use the following filter:\n\n```javascript\n{ version: 4, size: [ 2048, 4096 ] }\n```\n\nThe keys of the filter object are the properties to filter by, the values are the values to match.\nThere are different classes that you can use instead of specifying the values directly:\n\n* `new pgp.Keyring.Filter.Equals(\"test\")`: Matches `\"test\"`\n* `new pgp.Keyring.Filter.ArrayContains(\"test\")`: Matches arrays that contain `\"test\"`\n* `new pgp.Keyring.Filter.EqualsIgnoreCase(\"test\")`: Matches `\"test\"`, `\"TEST\"`, `\"tEsT\"` and so on\n* `new pgp.Keyring.Filter.ContainsIgnoreCase(\"test\")`: Matches arrays that contain `\"test\"`, `\"TEST\"`,\n  `tEsT` and so on\n* `new pgp.Keyring.Filter.ShortKeyId(\"0A1B2C3D\")`: Matches long key IDs like `\"000000000A1B2C3D\"`\n* `new pgp.Keyring.Filter.LessThan(5)`: Matches numbers less than 5\n* `new pgp.Keyring.Filter.LessThanOrEqual(5)`: Matches numbers less than or equal 5\n* `new pgp.Keyring.Filter.GreaterThan(5)`: Matches numbers greater than 5\n* `new pgp.Keyring.Filter.GreaterThanOrEqual(5)`: Matches numbers greater than or equal\n* `new pgp.Keyring.Filter.Not(new pgp.Keyring.Filter.Equals(\"test\"))`: Matches everything but `\"test\"`\n* `new pgp.Keyring.Filter.Or(new pgp.Keyring.Filter.Equals(\"test1\"), new pgp.Keyring.Filter.Equals(\"test2\"),\n  new pgp.Keyring.Filter.Equals(\"test3\")`: Matches `\"test1\"`, `\"test2\"`, `\"test3\"`\n* `new pgp.Keyring.Filter.And(new pgp.Keyring.Filter.Equals(\"test1\"), new pgp.Keyring.Filter.Equals(\"test2\"),\n  new pgp.keyring.Filter.Equals(\"test3\")`: Matches nothing\n\nFor example, to look up all version 4 keys with a key size 2048 or greater, use the following filter:\n\n```javascript\n{ version: 4, size: new pgp.Keyring.Filter.GreaterThanOrEqual(2048) }\n```\n\n\nObject info\n-----------\n\n### Public key info ###\n\nObjects of this type may contain the following properties:\n\n* `pkt`: `consts.PKT.PUBLIC_KEY`\n* `id`: The long ID of the key, a 16-digit hex number as upper-case String\n* `binary`: The binary packet content containing this key (Buffer)\n* `version`: The key version, either 3 or 4\n* `versionSecurity`: How secure the key version makes this key, one of [`consts.SECURITY`](#security-level)\n* `expires`: `null` or a Date object indicating the expiration date of the key.\n  Note that only v3 keys can have this defined in the key itself, and it can be\n  overridden by self-signatures.\n* `date`: A Date object indicating when the key was created.\n* `pkalgo`: One of [`consts.PKALGO`](#public-key-algorithm)\n* `keyParts`: An object containing the relevant key parts as [MPI](#mpi) objects\n  Algorithm specific, might contain the values `n`, `e`, `p`, `q`, `g` and `y`\n* `fingerprint`: The fingerprint, a 32-digit hex number as upper-case String\n* `size`: The key size in bits\n* `sizeSecurity`: How secure the size makes this key, one of [`consts.SECURITY`](#security-level)\n* `security`: The overall security of this key’s properties, one of [`consts.SECURITY`](#security-level)\n\n\n### Public subkey info ###\n\nObjects of this type may contain the same properties as [public keys](#public-key-info),\nexcept that `pkt` is `consts.PKT.PUBLIC_SUBKEY`.\n\n\n### User ID info ###\n\nObjects of this type may contain the following properties:\n\n* `pkt`: `consts.PKT.USER_ID`\n* `name` : The name part of the ID as String\n* `email` : The e-mail part of the ID as String\n* `comment` : The comment part of the ID as String\n* `binary` : The binary packet content containing this identity (Buffer)\n* `id` : The whole ID as String\n* `nameTrust` : How reliable it is that this key belongs to a person with the name of\n  this identity, where 1.0 is considered to be reliable.\n* `emailTrust` : How reliable it is that this key belongs to the person who own the\n  e-mail address of this identity, where 1.0 is considered to be reliable.\n\n\n### Attribute info ###\n\n* `pkt`: `consts.PKT.ATTRIBUTE`,\n* `id`: An ID string to use for the attribute. This is a hash of the packet\n  body. Not part of the OpenPGP standard.\n* `subPackets` : An array of objects:\n\t* `type`: The sub-packet type, one of [`consts.ATTRSUBPKT`](#attribute-sub-packets)\n\t* `binary`: A buffer object with the body of the sub-packet\n\t* `image`; If `type` is `consts.ATTRSUBPKT.IMAGE`, this is a Buffer with the\n\t  image data.\n\t* `imageType`: If `type` is `consts.ATTRSUBPKT.IMAGE`, this is  the image\n\t  type, one of [`consts.IMAGETYPE`](#attribute-sub-packet-image-types)\n* `binary` : The binary packet content containing this attribute (Buffer)\n* `trust` : How reliable it is that this key belongs to the person who is depicted\n  on this picture, where 1.0 is considered to be reliable.\n\n\n### Signature info ###\n\n* `pkt`: `consts.PKT.SIGNATURE`,\n* `id` : An ID string created from a hash of this signature. Not part of the\n  OpenPGP standard.\n* `sigtype`: The signature type, one of [`consts.SIGTYPE`](#signature-type).\n* `date`: A Date object when the signature was issued\n* `issuer`: The long ID of the issuer key. A 16-digit upper-case hex string.\n* `pkalgo`: The public key algorithm, one of [`consts.PKALGO`](#public-key-algorithm)\n* `hashalgo`: The hash algorithm, one of [`consts.HASHALGO`](#hash-algorithm)\n* `version`: The signature packet version, 3 or 4\n* `binary`: The binary packet content containing this attribute (Buffer)\n* `hashedSubPackets`: An object with the hashed sub-packets\n   (see [the RFC](http://tools.ietf.org/html/rfc4880#section-5.2.3.1)). The keys\n   are the sub-packet types (one of [`consts.SIGSUBPKT`](#signature-sub-packet-type)),\n   the values are arrays of objects with the following keys:\n\t* `critical`: A boolean, if true, the whole signature should be ignored if\n\t  the software does not know how to handle this sub-packet type.\n\t* `rawValue`: A Buffer with the body of the sub-packet\n\t* `value`: The body of the sub-packet mapped to an appropriate JavaScript\n\t  type, or null if no mapped value is known.\n* `unhashedSubPackets`: Like `hashedSubPackets`, but these packets are not\n  hashed by the signature, so their content is not reliable, even after the\n  signature has been verified.\n* `exportable`: A boolean indicating whether this signature may be exported.\n* `expires`: A Date object when this signature expires or null if it does not.\n* `hashedPart`: A Buffer with the hashed part of the signature. This part is\n  used by the algorithm for making the signature.\n* `first2HashBytes`: The first two bytes of the hash as 16-bit unsigned integer\n* `signature`: A Buffer object with the actual signature part of the signature\n* `hashalgoSecurity`: The security of the hash algorithm used in this signature,\n  one of [`consts.SECURITY`](#security-level)\n* `security`: The overall security of this signatures parameters, one of\n  [`consts.SECURITY`](#security-level)\n* `verified`: Whether it has been verified that this signature has actually been\n  issued by its issuer (Boolean)\n* `trustSignature`: Whether this signature is a trust signature (Boolean)\n\n\nConstants\n---------\n\n### Packet type ###\n\n`pgp.consts.PKT` contains the numbers representing packet types.\n\n\tNONE          : 0,\n\tPUBKEY_ENC    : 1,  /* Public key encrypted packet. */\n\tSIGNATURE     : 2,  /* Secret key encrypted packet. */\n\tSYMKEY_ENC    : 3,  /* Session key packet. */\n\tONEPASS_SIG   : 4,  /* One pass sig packet. */\n\tSECRET_KEY    : 5,  /* Secret key. */\n\tPUBLIC_KEY    : 6,  /* Public key. */\n\tSECRET_SUBKEY : 7,  /* Secret subkey. */\n\tCOMPRESSED    : 8,  /* Compressed data packet. */\n\tENCRYPTED     : 9,  /* Conventional encrypted data. */\n\tMARKER        : 10, /* Marker packet. */\n\tPLAINTEXT     : 11, /* Literal data packet. */\n\tRING_TRUST    : 12, /* Keyring trust packet. */\n\tUSER_ID       : 13, /* User id packet. */\n\tPUBLIC_SUBKEY : 14, /* Public subkey. */\n\tOLD_COMMENT   : 16, /* Comment packet from an OpenPGP draft. */\n\tATTRIBUTE     : 17, /* PGP's attribute packet. */\n\tENCRYPTED_MDC : 18, /* Integrity protected encrypted data. */\n\tMDC           : 19, /* Manipulation detection code packet. */\n\tCOMMENT       : 61, /* new comment packet (GnuPG specific). */\n\tGPG_CONTROL   : 63  /* internal control packet (GnuPG specific). */\n\n### Signature type ###\n\n`pgp.consts.SIG` contains the numbers representing signature types.\n\n\tBINARY        : 0x00, /* Signature of a binary document. */\n\tTEXT          : 0x01, /* Signature of a canonical text document. */\n\tSTANDALONE    : 0x02, /* Standalone signature. */\n\tCERT_0        : 0x10, /* Generic certification of a User ID and Public-Key packet. */\n\tCERT_1        : 0x11, /* Persona certification of a User ID and Public-Key packet. */\n\tCERT_2        : 0x12, /* Casual certification of a User ID and Public-Key packet. */\n\tCERT_3        : 0x13, /* Positive certification of a User ID and Public-Key packet. */\n\tSUBKEY        : 0x18, /* Subkey Binding Signature */\n\tKEY_BY_SUBKEY : 0x19, /* Primary Key Binding Signature */\n\tKEY           : 0x1F, /* Signature directly on a key */\n\tKEY_REVOK     : 0x20, /* Key revocation signature */\n\tSUBKEY_REVOK  : 0x28, /* Subkey revocation signature */\n\tCERT_REVOK    : 0x30, /* Certification revocation signature */\n\tTIMESTAMP     : 0x40, /* Timestamp signature. */\n\tTHIRDPARTY    : 0x50, /* Third-Party Confirmation signature. */\n\n### Signature sub-packet type ###\n\n`pgp.consts.SIGSUBPKT` contains the numbers representing signature sub-packet\ntypes.\n\n\tNONE          :  0,\n\tSIG_CREATED   :  2, /* Signature creation time. */\n\tSIG_EXPIRE    :  3, /* Signature expiration time. */\n\tEXPORTABLE    :  4, /* Exportable. */\n\tTRUST         :  5, /* Trust signature. */\n\tREGEXP        :  6, /* Regular expression. */\n\tREVOCABLE     :  7, /* Revocable. */\n\tKEY_EXPIRE    :  9, /* Key expiration time. */\n\tARR           : 10, /* Additional recipient request. */\n\tPREF_SYM      : 11, /* Preferred symmetric algorithms. */\n\tREV_KEY       : 12, /* Revocation key. */\n\tISSUER        : 16, /* Issuer key ID. */\n\tNOTATION      : 20, /* Notation data. */\n\tPREF_HASH     : 21, /* Preferred hash algorithms. */\n\tPREF_COMPR    : 22, /* Preferred compression algorithms. */\n\tKS_FLAGS      : 23, /* Key server preferences. */\n\tPREF_KS       : 24, /* Preferred key server. */\n\tPRIMARY_UID   : 25, /* Primary user id. */\n\tPOLICY        : 26, /* Policy URL. */\n\tKEY_FLAGS     : 27, /* Key flags. */\n\tSIGNERS_UID   : 28, /* Signer's user id. */\n\tREVOC_REASON  : 29, /* Reason for revocation. */\n\tFEATURES      : 30, /* Feature flags. */\n\tSIGTARGET     : 31, /* Signature target */\n\tSIGNATURE     : 32, /* Embedded signature. */\n\n\tFLAG_CRITICAL : 128\n\n### Public key algorithm ###\n\n`pgp.consts.PKALGO` contains the numbers representing public key algorithms.\n\n\tRSA_ES        : 1, /* RSA (Encrypt or Sign) */\n\tRSA_E         : 2, /* RSA Encrypt-Only */\n\tRSA_S         : 3, /* RSA Sign-Only */\n\tELGAMAL_E     : 16, /* Elgamal (Encrypt-Only) */\n\tDSA           : 17 /* DSA (Digital Signature Algorithm) */\n\n### Hash algorithm ###\n\n`pgp.consts.HASHALGO` contains the numbers representing public key algorithms.\n\n\tMD5           : 1,\n\tSHA1          : 2,\n\tRIPEMD160     : 3,\n\tSHA256        : 8,\n\tSHA384        : 9,\n\tSHA512        : 10,\n\tSHA224        : 11\n\n### Attribute sub-packets ###\n\n`pgp.consts.ATTRSUBPKT` contains the numbers representing attribute sub-packet\ntypes.\n\n\tIMAGE         : 1\n\n### Attribute sub-packet image types ###\n\n`pgp.consts.IMAGETYPE` contains the numbers representing attribute sub-packet\nimage types.\n\n\tJPEG          : 1\n\n### Armored message type ###\n\n`pgp.consts.ARMORED_MESSAGE` contains the types that ASCII-armored PGP messages\ncan have.\n\n\tMESSAGE       : \"MESSAGE\",\n\tPUBLIC_KEY    : \"PUBLIC KEY BLOCK\",\n\tPRIVATE_KEY   : \"PRIVATE KEY BLOCK\",\n\tSIGNATURE     : \"SIGNATURE\"\n\n### Security level ###\n\n`pgp.consts.SECURITY` defines level to indicate the security of key parameters.\n\n\tUNKNOWN      : -1,\n\tUNACCEPTABLE : 0,\n\tBAD          : 1,\n\tMEDIUM       : 2,\n\tGOOD         : 3\n\n\nFormat conversion functions\n===========================\n\nOpenPGP data can come in two different formats: in binary or “ASCII-armored”\nusing base-64. These methods allow working with the different formats.\n\n## formats.decodeKeyFormat(data) ##\n\nThis method converts the input data to the binary format, automatically\ndetecting the format of the input data. `data` can be a Readable Stream, a\nBuffer, or a String. The function returns a [`BufferedStream`](#bufferedstream),\nsee below how to work with that.\n\n```javascript\npgp.formats.decodeKeyFormat(fs.createReadStream(\"/tmp/test.asc\")).readUntilEnd(function(err, data) {\nif(err)\n\t\t; // An error occurred\n\telse\n\t\t; // data is a Buffer with the data in binary format\n});\n```\n\n## formats.dearmor(data) ##\n\nConverts the input data from armored ASCII to the binary format. `data` can be\na Readable Stream, a Buffer, or a String. The function returns a\n[`BufferedStream`](#bufferedstream).\n\n```javascript\npgp.formats.dearmor(fs.createReadStream(\"/tmp/test.asc\")).readUntilEnd(function(err, data) {\n\tif(err)\n\t\tconsole.warn(\"An error occurred\", err);\n\telse\n\t\t; // data is a Buffer with the data in binary format\n});\n```\n\n## formats.enarmor(data, messageType) ##\n\nConverts the input data from binary format to armored ASCII format. `data` can\nbe a Readable Stream, a Buffer, or a String. `messageType` is one of [`pgp.consts.ARMORED_MESSAGE`](#armored-message-type).\nThe function returns a [`BufferedStream`](#bufferedstream).\n\n```javascript\npgp.formats.enarmor(fs.createReadStream(\"/tmp/test.pgp\"), pgp.consts.ARMORED_MESSAGE).readUntilEnd(function(err, data) {\n\tif(err)\n\t\tconsole.warn(\"An error occurred\", err);\n\telse\n\t\t; // data is a Buffer with the armored data encoded in UTF-8\n});\n```\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/cdauth/node-pgp.git"
  },
  "scripts": {
    "test": "tests/run.sh"
  },
  "version": "0.0.1"
}
